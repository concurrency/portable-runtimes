<html><head><title>API map.vue</title><script src="http://ajax.googleapis.com/ajax/libs/jquery/1.3.1/jquery.min.js" type="text/javascript"></script><script  type="text/javascript">
jQuery.noConflict();
</script>
<script src="http://vue.tufts.edu/htmlexport-includes/jquery.maphilight.min.js" type="text/javascript"></script><script src="http://vue.tufts.edu/htmlexport-includes/v3/tooltip.min.js" type="text/javascript"></script><script type="text/javascript">jQuery(function() {jQuery.fn.maphilight.defaults = {
         fill: false,
         fillColor: '000000',
         fillOpacity: 0.2,
             stroke: true,
         strokeColor: '282828',
         strokeOpacity: 1,
         strokeWidth: 4,
         fade: true,
         alwaysOn: false
     }
jQuery('.example2 img').maphilight();
});
</script>
<style type="text/css">
#tooltip{
position:absolute;
border:1px solid #333;
background:#f7f5d1;
padding:2px 5px;
color:#333;
display:none;
}
</style>
</head><body>
<div class="example2"><img class="map" src="Plumbing API.png" width="1540.0" height="877.0" usemap="#vuemap"><map name="vuemap"> <area   id="node0" shape="rect" coords="674,242,827,266"></area>
 <area   id="node1" shape="rect" coords="674,266,798,287"></area>
 <area   id="node2" shape="rect" coords="674,200,800,221"></area>
 <area   id="node3" shape="rect" coords="674,221,787,242"></area>
 <area   id="node4" shape="rect" coords="674,179,802,200"></area>
 <area   id="node5" shape="rect" coords="674,158,780,179"></area>
 <area   id="node6" shape="rect" coords="674,117,810,138"></area>
 <area   id="node7" shape="rect" coords="674,137,783,158"></area>
 <area  class="tooltip" title="Generates a 
consistent stream 
of SIGNALs.

 
Every [@code 
period] 
milliseconds, a 
SIGNAL is 
generated.



 
@param period A 
delay time in 
milliseconds.

 
@param out SIGNALs 
generated after 
the given delay."  id="node8" shape="rect" coords="1117,598,1382,625"></area>
 <area  class="tooltip" title="Outputs an 
alternating stream 
of LEVEL values.

Starting with an 
initial level 
(either LOW or 
HIGH), this 
process outputs a 
stream of 
alternating LEVEL 
values upon 
request. On 
receiving a 
SIGNAL, the next 
LEVEL is emitted



@param initial.
level Either LOW 
or HIGH to start.

@param in The 
request line.

@param out The 
alternating stream 
of LEVEL values."  id="node9" shape="rect" coords="1117,400,1523,427"></area>
 <area  class="tooltip" title="Drives a pin 
alternately LOW 
and HIGH.

 Upon 
request, 
alternates the 
level of a pin 
from LOW to HIGH.



@param pin The 
(digital) Arduino 
pin we want to 
drive.

@param 
initial.level 
Either LOW or HIGH."  id="node10" shape="rect" coords="32,482,429,509"></area>
 <area  class="tooltip" title="Drives a pin 
alternately LOW 
and HIGH on a 
fixed cycle. Every 
[@code delay.time] 
milliseconds, 
toggles a pin.



@param pin The 
Arduino pin.

@param delay.time 
The number of 
milliseconds 
between toggles."  id="node11" shape="rect" coords="37,556,253,583"></area>
 <area  class="tooltip" title="Blinks the LED.PIN 
every 500ms.

A 
parallel health 
monitor."  id="node12" shape="rect" coords="37,583,162,610"></area>
 <area  class="tooltip" title="Reads the analog 
value of a given 
pin.

Upon 
request, performs 
an analog to 
digital 
conversion, 
comparing the

voltage at [@code 
analog.pin] with 
the specified 
reference voltage. 
No matter which 
reference is used, 
the value of 
[@code out] will 
always

rest 
between 0 and 
1023.



 There is 
a safeguard put in 
place that should 
allow [@code 
analog.pin] to be 
properly read if 
written as 0, 1, 
2, etc., but it is 
still recommended 
that

one writes 
A0, A1, etc. to 
avoid confusion.

 
@param analog.pin 
The Analog pin 
number. (A0, A1, 
A2)

 @param ref 
The source of the 
reference voltage. 
Either VCC 
(default),

AREF 
(external), or 
INTERNAL (1.1v 
internal 
reference).

 
@param in The 
request line.

 
@param out The 
output channel for 
converted 
readings. 0 - 1023."  id="node13" shape="rect" coords="17,656,438,683"></area>
 <area  class="tooltip" title="Reads from a 
potentiometer and 
maps the incoming 
value to a BYTE.

Upon request, the 
incoming value 
from a 
potentiometer (a 
knob, slider...)

connected to 
[@code analog.pin] 
to will be mapped 
to an appropriate 
value between 0-
255.

There is a 
safeguard put in 
place that should 
allow [@code 
analog.pin] to be 
properly read if 
written as 0, 1, 
2, etc., but it is 
still recommended 
that

one writes 
A0, A1, etc. to 
avoid confusion.



@param analog.pin 
The analog pin the 
potentiometer is 
connected to.

@param in The 
request line.

@param out The 
output chanel for 
mapped values. 0-
255"  id="node14" shape="rect" coords="17,683,459,710"></area>
 <area  class="tooltip" title="Limits the range 
of values in a 
stream.

Takes 
[@code low] and 
[@code high] as 
limits, and any 
BYTEs read in that 
are below [@code 
low] are clamped 
to [@code low], 
and likewise

with 
the [@code high] 
value.



@param 
low The lower 
limit for valid 
numbers.

@param 
high The upper 
limit for valid 
numbers.

@param 
in The input 
stream of BYTEs.

@param out The 
output stream of 
BYTEs"  id="node15" shape="rect" coords="1117,454,1454,481"></area>
 <area  class="tooltip" title="Limits the range 
of values in a 
stream.

Takes 
[@code low] and 
[@code high] as 
limits, and any 
INTs read in that  
are below [@code 
low] are clamped 
to [@code low], 
and likewise with 
the [@code high] 
value.



@param 
low The lower 
limit for valid 
numbers.

@param 
high The upper 
limit for valid 
numbers.

@param 
in The input 
stream of INTs.

@param out The 
output stream of 
INTs.

"  id="node16" shape="rect" coords="1117,481,1424,508"></area>
 <area  class="tooltip" title="Crawls a BYTE from 
0 to [@code high] 
and back down (and 
back up, etc.). 
Pausing [@code 
wait] milliseconds 
between each 
signal send, and 
incrementing (in 
either direction) 
[@code step] 
between each send, 
the outgoing value

 is capped at 0 
and [@code high].



@param high The 
upper limit of 
output values.

@param step The 
increment between 
each send.

 
@param wait The 
time - in 
milliseconds - to 
wait after a 
successful send

before attempting 
another.

 @param 
out The output 
stream of BYTEs."  id="node17" shape="rect" coords="1117,544,1499,571"></area>
 <area  class="tooltip" title="Crawls an INT from 
0 to [@code high] 
and back down (and 
back up, etc.). 
Pausing [@code 
wait] milliseconds 
between each 
signal send, and 
incrementing (in 
either direction) 
[@code step] 
between each send, 
the outgoing value 
is capped at 0 and 
[@code high].



@param high The 
upper limit of 
output values.

@param step The 
increment between 
each send.

@param 
wait The time - in 
milliseconds - to 
wait after a 
successful send 
before attempting 
another.

@param 
out The output 
stream of INTs"  id="node18" shape="rect" coords="1117,571,1472,598"></area>
 <area  class="tooltip" title="Writes an analog 
value to a pin.

For a given (PWM) 
pin, sets the 
observed analog 
level to a value 
between 0 and 255. 
Negative values 
are treated as 0, 
and values greater

than 255 are 
treated as 255.



@param board.pin 
The pin number.

@param level The 
input level 
channel."  id="node19" shape="rect" coords="16,750,303,777"></area>
 <area  class="tooltip" title="Writes an analog 
value to a pin.

 
For a given (PWM) 
pin, sets the 
level to a value 
between 0 and 
[@code top]. 
Negative values 
are treated as 0, 
and values greater 
than [@code top] 
are treated as 
[code top].



[@em Be careful]. 
Not every PWM pin 
is connected to a 
16 bit timer, so 
not every pin 
labeled as a PWM 
can be used with 
this PROC.



@param board.pin 
The Arduino pin 
number

@param top 
The highest level 
top can be set to.

@param level The 
input level 
channel."  id="node20" shape="rect" coords="16,777,371,804"></area>
 <area  class="tooltip" title="* Wait for a 
period of time.

 
@param millis Time 
to wait, in 
milliseconds
"  id="node21" shape="rect" coords="1117,625,1291,652"></area>
 <area  class="tooltip" title="Watches for button 
presses on 
external level 
interrupt pins. 
When a button is 
pressed a SIGNAL 
is generated. Uses 
digital.input, 
debounce, and 
level.to.signal.



@param board.pin 
The pin the button 
is connected  
(pins 2 and 3 are 
safe bets).

@param out SIGNALs 
generated when the 
button is pressed."  id="node22" shape="rect" coords="42,359,362,386"></area>
 <area  class="tooltip" title="Sets the digital 
state of a pin to 
either HIGH or 
LOW.

This PROC 
does NOT set pin.
mode!!

 @param 
board.pin The 
board pin to be 
set.

@param state 
The state to set 
-- Either HIGH or 
LOW"  id="node23" shape="rect" coords="32,428,342,455"></area>
 <area  class="tooltip" title="Reads the digital 
state of a pin. 
Either HIGH or 
LOW.

This PROC 
does NOT set pin.
mode!!



@param 
board.pin The 
board pin to be 
read.

@param 
state The pin's 
current state -- 
Either HIGH or LOW."  id="node24" shape="rect" coords="42,305,372,332"></area>
 <area  class="tooltip" title="Sets the Data 
Direction Register 
of the given pin 
(sets the flow of 
data) to either 
INPUT or OUTPUT.



@param board.pin 
The board pin to 
set the direction 
of.

@param mode 
The mode to be 
set. Either INPUT 
or OUTPUT"  id="node25" shape="rect" coords="1061,186,1322,213"></area>
 <area  class="tooltip" title="Set digital levels 
on a pin.

Reads 
LEVEL values (LOW 
or HIGH) on the 
input channel, and 
sets the value of 
the specified pin 
accordingly.



@param board.pin 
The Arduino pin 
number

@param in 
Pin levels (LOW or 
HIGH)"  id="node26" shape="rect" coords="32,455,351,482"></area>
 <area  class="tooltip" title="Read digital 
levels on external 
level interrupt 
pins.

This 
procedure will 
output a LEVEL 
(either LOW or 
HIGH) whenever the 
pin changes value.



@param board.
pin The pin number 
(pins 2 and 3 are 
safe choices).

@param out The 
LEVEL, output when 
the pin changes 
level."  id="node27" shape="rect" coords="42,332,358,359"></area>
 <area  class="tooltip" title="Invert LEVELs.

Reads in LEVEL 
values, and 
outputs the 
opposite.

 Upon 
receiving a LOW, 
sends a HIGH, and 
visa versa.



@param in Incoming 
LEVEL values.

@param out 
Outgoing LEVEL 
values, inverted."  id="node28" shape="rect" coords="1117,373,1355,400"></area>
 <area  class="tooltip" title="Convert a LEVEL to 
a SIGNAL.

Consumes a stream 
of LEVEL values, 
and emits a 
SIGNAL  for each 
LEVEL received, 
regardless of 
whether it is LOW 
or HIGH.



@param 
in Input LEVEL 
values.

@param 
out Output SIGNALs."  id="node29" shape="rect" coords="1117,346,1441,373"></area>
 <area  class="tooltip" title="Unary (logical) 
negation operator 
for the LEVEL 
type. Enables the 
use of [@code 
level := NOT 
level], where 
[@code level] is 
of type [@code 
LEVEL].



@private

@param l 
Input value

@returns HIGH if l 
is LOW, LOW 
otherwise

"  id="node30" shape="rect" coords="1117,427,1404,454"></area>
 <area   id="node31" shape="rect" coords="618,456,925,660"></area>
 <area   id="node32" shape="rect" coords="674,287,769,308"></area>
 <area   id="node33" shape="rect" coords="674,308,792,329"></area>
 <area   id="node34" shape="rect" coords="674,329,799,350"></area>
 <area  class="tooltip" title="Kills everything 
and reports an 
error back to the 
user.

@param 
error A string 
containing the 
error message."  id="node35" shape="rect" coords="1064,268,1240,295"></area>
 <area  class="tooltip" title="* Begins serial 
operations on the 
given board pin.

[@code board.pin] 
[@em must] be 
written as TX0, 
RX0, TX1, RX1, 
etc.  In the case 
of this process, 
RX0 and TX0 will 
both signal the 
activation of 
serial port 0, as 
RX1 and TX1 will 
activate port 1, 
etc. the 'R' and 
'T' can be used 
interchangeably.

 
@param board.pin 
The board pin to 
being serial 
operations on.
@param baud The 
baud rate at which 
to transmit serial 
data.
"  id="node36" shape="rect" coords="1071,688,1377,715"></area>
 <area  class="tooltip" title="* Reads a BYTE 
from the given 
pin.
--
[@code 
board.pin] [@em 
must] be written 
as TX0, RX0, TX1, 
RX1, etc.
@param 
board.pin The pin 
from which to 
read.
@param b The 
resulting byte 
from the read.
"  id="node37" shape="rect" coords="1071,715,1398,742"></area>
 <area  class="tooltip" title="* Write a BYTE to 
the given pin.

[@code board.pin] 
[@em must] be 
written as TX0, 
RX0, TX1, RX1, 
etc.
 @param board.
pin The board pin 
to be written to.
 
@param b The BYTE 
to be written."  id="node38" shape="rect" coords="1071,742,1378,769"></area>
 <area   id="node39" shape="rect" coords="1071,769,1331,790"></area>
 <area   id="node40" shape="rect" coords="1071,790,1355,811"></area>
 <area   id="node41" shape="rect" coords="1071,811,1380,832"></area>
 <area   id="node42" shape="rect" coords="1071,832,1301,853"></area>
 <area  class="tooltip" title="-* Stepping-stone 
servo control 
process.
 The idea 
is this is a 
simpler process to 
work with servos 
than the  
PROTOCOL. You need 
to know your 
servo's bounds for 
this one, but it 
does
allow for a 
single-channel 
servo control.

@param board.pin 
The board pin to 
be used for servo 
operations. For 
the  time being, 
only PWM pins 
connected to a 16 
bit timer can be 
used to
operate 
servos.
 @param 
umin The shortest 
pulse the servo is 
designed to 
recieve.
 @param 
umax The longest 
pluse the servo is 
designed to 
recieve.
 @param 
p? The input BYTE 
channel for 
setting the 
position of the 
servo.
 [@em This 
is hard-coded to 
be a range from 0 
to 180. Do not 
attempt to
--   
send anything 
outside of that 
range.]"  id="node43" shape="rect" coords="606,804,974,831"></area>
 <area  class="tooltip" title="A more complex 
servo driver, 
using
an occam 
protocol. Called 
by Simple.servo

I 
have not looked at 
this code yet!
"  id="node44" shape="rect" coords="606,831,884,858"></area>
 <area   id="node45" shape="rect" coords="363,190,425,213"></area>

</map></div></body></html>